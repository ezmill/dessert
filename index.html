<!DOCTYPE html>
<html lang="en" style="visibility: visible;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<title>dessert</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				/*cursor: none;*/
			}
			canvas{
				width: 1440px;
				height: 742px;
			}
		</style>
	<style type="text/css"></style></head>
	<body cz-shortcut-listen="true">
		<script type="x-shader/x-vertex" id="vertexShader">

			attribute vec4 tangent;

			uniform float time;
			uniform vec2 repeat;
			uniform float useNormal;
			uniform float useRim;

			varying vec2 vUv;
			varying vec3 vTangent;
			varying vec3 vBinormal;
			varying vec3 vNormal;
			varying vec3 vEye;
			varying vec3 vU;
			varying vec2 vN;

			void main() {

				vU = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );

				if( useNormal == 0. ) {
					vec3 n = normalize( normalMatrix * normal );
					vec3 r = reflect( vU, n );
					float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );
					vN = vec2( r.x / m + 0.5,  r.y / m + 0.5 );
				} else {
					vN = vec2( 0. );
				}

				vUv = repeat * uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				vNormal = normalize( normalMatrix * normal );
				if( useNormal == 1. ) {
					vTangent = normalize( normalMatrix * tangent.xyz );
					vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );
				} else {
					vTangent = vec3( 0. );
					vBinormal = vec3( 0. );
				}

				if( useRim > 0. ) {
					vEye = ( modelViewMatrix * vec4( position, 1.0 ) ).xyz;
				} else {
					vEye = vec3( 0. );
				}

			}

			</script>
			
			<script type="x-shader/x-vertex" id="fragmentShader">
			
			uniform float time;
			uniform float bump;
			uniform sampler2D tNormal;
			uniform sampler2D tMatCap;
			uniform float noise;
			uniform float useNormal;
			uniform float useRim;
			uniform float rimPower;
			uniform float useScreen;
			uniform float normalScale;
			uniform float normalRepeat;
			uniform float opacity;

			varying vec2 vUv;
			varying vec3 vTangent;
			varying vec3 vBinormal;
			varying vec3 vNormal;
			varying vec3 vEye;
			varying vec3 vU;
			varying vec2 vN;

			float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}

			void main() {
				
				vec3 finalNormal = vNormal;
				vec2 calculatedNormal = vN;

				if( useNormal == 1. ) {
					vec3 normalTex = texture2D( tNormal, vUv * normalRepeat ).xyz * 2.0 - 1.0;
					normalTex.xy *= normalScale;
					normalTex.y *= -1.;
					normalTex = normalize( normalTex );
					mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );
					finalNormal = tsb * normalTex;

					vec3 r = reflect( vU, normalize( finalNormal ) );
					float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );
					calculatedNormal = vec2( r.x / m + 0.5,  r.y / m + 0.5 );
				}

				vec3 base = texture2D( tMatCap, calculatedNormal ).rgb;
				// base.b = 0.5+0.5*sin(time*2.0);

				// rim lighting

				if( useRim > 0. ) {
					float f = rimPower * abs( dot( vNormal, normalize( vEye ) ) );
					f = useRim * ( 1. - smoothstep( 0.0, 1., f ) );
			        base += vec3( f );
			    }

			    // screen blending

		        if( useScreen == 1. ) {
					base = vec3( 1. ) - ( vec3( 1. ) - base ) * ( vec3( 1. ) - base );
				}

		        // noise 

		        base += noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) );

				gl_FragColor = vec4( base, opacity );

			}
			
			</script>
		<script src="js/three.min.js"></script>
		<script src="js/ThreeJsUtils.js"></script>

		<script src="js/OrbitControls.js"></script>
		<script src="js/FeedbackMaterial.js"></script>
		<script src="js/GradientShader.js"></script>
		<script src="js/CustomShaders.js"></script>
		<script src="js/CCapture.min.js"></script>
		<script src="js/gif.js"></script>
		<script src="js/gif.worker.js"></script>
		<script src="js/Whammy.js"></script>
		<script id="vs" type="x-shader/x-vertex">

			uniform sampler2D map;

			uniform float width;
			uniform float height;
			uniform float nearClipping, farClipping;

			varying vec2 vUv;

			const float XtoZ = 1.11146; // tan( 1.0144686 / 2.0 ) * 2.0;
			const float YtoZ = 0.83359; // tan( 0.7898090 / 2.0 ) * 2.0;

			void main() {

				vUv = vec2( position.x / width, 1.0 - ( position.y / height ) );

				// vec4 color = texture2D( map, vUv );
				// float depth = ( color.r + color.g + color.b ) / 3.0;

				// Projection code by @kcmic

				// float z = ( 1.0 - depth ) * (farClipping - nearClipping) + nearClipping;

				vec4 pos = vec4(
					( position.x / width - 0.5 ) * 10000.0 * XtoZ,
					( position.y / height - 0.5 ) * 10000.0 * YtoZ,
					-1000.0,
					1.0);

				gl_PointSize = 3.0;
				gl_Position = projectionMatrix * modelViewMatrix * pos;

			}

		</script>

		<script id="fs" type="x-shader/x-fragment">

			uniform sampler2D map;

			varying vec2 vUv;

			void main() {

				vec4 color = texture2D( map, vUv );
				// gl_FragColor = vec4( color.r, color.g, color.b, smoothstep( 8000.0, -8000.0, gl_FragCoord.z / gl_FragCoord.w ) );
				gl_FragColor = vec4( color.r, color.g, color.b, 1.0 );

			}

		</script>

		<script>

			var container;

			var scene, camera, light, renderer;
			var geometry, cube, mesh, material;
			var mouse = new THREE.Vector2(), center;
			var stats;
			var container;
			var scene, renderer, camera, controls;
			var fbScene, fbRenderer, fbCamera, fbTexture, fbShaders, fbMaterial;
			var mouseX = 0, mouseY = 0;
			var time = 0;
			var texture;
			var windowHalfX = window.innerWidth / 2;
			var w = window.innerWidth;
			var windowHalfY = window.innerHeight / 2;
			var h = window.innerHeight;

			var start = Date.now(); 
			var gradient, tex;
			var meshes = [];
			var obj;
			var counter = 0;
			var rtt;
			var captureFrame = 0;
			var sizeMult = 1;
			var capturer = new CCapture( { format: 'webm', workersPath: 'js/' } );
			var range = 100.0;
			var video, texture;
			var expand = false;
			var target;
			var _scene, _camera, _renderer;
			init();
			fbInit();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );


				// scene = new THREE.Scene();
// 
				// camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000000 );
				// camera.position.set( 0, 0, 2452.1003559896444 );
				// camera.position.set( 0, 0, 750 );
				// scene.add( camera );



				// renderer = new THREE.WebGLRenderer();
				// renderer.setSize( window.innerWidth, window.innerHeight );
				// renderer.setClearColor(0xffffff,1.0);
				_init();
				initCanvasTex();

				// var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(100,100), new THREE.MeshBasicMaterial({map:texture}));


				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );

			}
			function _init(){
				_scene = new THREE.Scene();
				// _camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 10000);
				_camera = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0.1, 10000)
				_camera.position.z = 500;
				// controls = new THREE.OrbitControls(_camera);
				_renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true, antialias: true});
				_renderer.setSize(window.innerWidth, window.innerHeight);
				_renderer.setClearColor(0xffffff, 1.0);

				// _geometry = new THREE.BoxGeometry(100,100,100);
				// _material = new THREE.MeshBasicMaterial({color: 0xff0000});
				// _mesh = new THREE.Mesh(_geometry, _material);
				// _scene.add(_mesh);

				target = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat });
				_material = new THREE.ShaderMaterial( {
				
					uniforms: { 
						tNormal:{type: 't', value: THREE.ImageUtils.loadTexture( 'textures/243-normal.jpg' ) },
						tMatCap:{type: 't', value: THREE.ImageUtils.loadTexture( 'textures/bluepink.png' ) },
						time:{type: 'f', value: 0 },
						bump:{type: 'f', value: 0 },
						noise:{type: 'f', value: .04 },
						repeat:{type: 'v2', value: new THREE.Vector2( 1, 1 ) },
						useNormal:{type: 'f', value: 0 },
						useRim:{type: 'f', value: 0 },
						rimPower:{type: 'f', value: 2 },
						useScreen:{type: 'f', value: 0 },
						normalScale:{type: 'f', value: .5 },
						normalRepeat:{type: 'f', value: 1 },
						time:{type:'f', value: time},
						opacity:{type:'f', value: 1.0}
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
					wrapping: THREE.ClampToEdgeWrapping,
					shading: THREE.SmoothShading,
					side: THREE.DoubleSide,

				} );

				_material.uniforms.tMatCap.value.wrapS = _material.uniforms.tMatCap.value.wrapT = 
				THREE.ClampToEdgeWrapping;
				
				_material.uniforms.tNormal.value.wrapS = _material.uniforms.tNormal.value.wrapT = 
				THREE.RepeatWrapping;

			    // container.appendChild(_renderer.domElement);

				// material = new THREE.MeshBasicMaterial({color:0xff0000});

				var loader = new THREE.JSONLoader();

				loader.load( 'logo.json', function( _geometry ) {
					
					var m = new THREE.Matrix4();
					var s = 300;
					m.scale( new THREE.Vector3( s, s, s) );

					THREE.GeometryUtils.center( _geometry );
					_geometry.vertices.forEach( function( v ) {
						v.applyMatrix4( m );
					} );

					_geometry.verticesNeedUpdate = true;
				    _geometry.normalsNeedUpdate = true;
				   	_geometry.uvsNeedUpdate = true;
				   	// geometry.computeCentroids();
				    // geometry.computeFaceNormals();
				    // geometry.computeVertexNormals();
				    // geometry.c/omputeMorphNormals();
				    // geometry.computeTangents();

					// var modifier = new THREE.SubdivisionModifier( 1 );
					// modifier.modify( geometry );

					_material.uniforms.repeat.value.set( 4, 4 );
					// callback( geometry );
					// _mesh = new THREE.Mesh( new THREE.TorusKnotGeometry(50,10,100,100), _material );
					_mesh = new THREE.Mesh( _geometry, _material );
					_mesh.useQuaternion = true;
					_scene.add( _mesh );
					_mesh.rotation.x += Math.PI/2;
					// _mesh.rotation.y += Math.PI*7/4;
					// _mesh.rotation.z += Math.PI*5/4;
				} );

			}
			function initCanvasTex(){
				// canvas = document.createElement("canvas");
				// canvas.width = window.innerWidth;
				// canvas.height = window.innerHeight;
				// ctx = canvas.getContext("2d");

				scene = new THREE.Scene();
				camera = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000)
				camera.position.z = 10;
				// controls = new THREE.OrbitControls(camera);
				renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0xffffff, 1.0);
				shader = new GradientShader();
				// video = document.createElement("video");
				// video.src = "textures/sky.m4v";
				// video.loop = true;
				// video.muted = true;
				// video.play();
				// video = document.createElement( 'video' );
				// video.muted = true;
				// navigator.webkitGetUserMedia({audio:false, video:true}, function(stream){
					// video.src = window.URL.createObjectURL(stream);
					// video.play();
				// }, function(err){
					// console.log(err);
				// });
				texture = new THREE.Texture(_renderer.domElement);
				texture.needsUpdate = true;
				// texture2 = new THREE.Texture(video);
				// texture2.needsUpdate = true;
				// texture2 = THREE.ImageUtils.loadTexture("textures/blue-sky-clouds.jpg");

				material = new THREE.ShaderMaterial({
					uniforms: shader.uniforms,
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader,
					transparent: true,
					side: 2
				})
				material.uniforms.time.value = time;
				material.uniforms.texture.value = texture;
				material.uniforms.texture2.value = null;
				// material.uniforms.texture.value = target.clone();
				geometry = new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight, 10, 10);
				mesh = new THREE.Mesh(geometry, material);
				scene.add(mesh);
			    fbTexture = new THREE.Texture(renderer.domElement);
			    fbTexture.needsUpdate = true;

			}
			var counter = 0;
			function onDocumentMouseDown(){
				// if(counter%2==0){
				// 	mesh.visible = false;
				// 	expand = true;
				// } else {
				// 	mesh.visible = true;
				// 	expand = false;
				// }
				// counter++;
				// _mesh.visible = false;
				mesh.material.uniforms.texO.value = 1.0;
				// mesh.material.uniforms.bgO.value = 0.0;
			}


			function animate() {
			  // setTimeout(function() {
					requestAnimationFrame( animate );
			    // }, 1000 / 30);
					render();

			}
			function _draw(){
		      	_material.uniforms.time.value = time;
				_renderer.clear(0xffffff);

				_renderer.render(_scene, _camera);

				// target.needsUpdate = true;
				// _renderer.render(_scene, _camera);
			}
			function render() {
			    time+=0.01;
				texture.needsUpdate = true;
				// texture2.needsUpdate = true;
				// material.uniforms.texture.value = target.clone();

				// material.uniforms.time.value = time;
				// texture.needsUpdate = true;
				// many();
				// _mesh.rotation.x += 0.01;
				if(hide){
					mesh.material.uniforms.texO.value += (0.0 - mesh.material.uniforms.texO.value)*0.01;
					mesh.material.uniforms.bgO.value += (1.0 - mesh.material.uniforms.bgO.value)*0.001;
					// mesh.uniforms.hideMesh = true;
					// _mesh.material.uniforms.opacity.value = 0.0;
				}
				_draw();

				renderer.render(scene, camera);
				// camera.position.x += ( mouse.x - camera.position.x ) * 0.05;
				// camera.position.y += ( - mouse.y - camera.position.y ) * 0.05;
				// camera.lookAt( center );
				// gradient.update();
				// fbRenderer.render( scene, camera );
			    fbDraw();


			}

			function fbInit(){

			    fbScene = new THREE.Scene();
			    fbCamera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 );
			    fbCamera.position.set(0,0,0);

			    // controls = new THREE.OrbitControls(fbCamera2);


			    fbRenderer = new THREE.WebGLRenderer({ preserveDrawingBuffer: true/*, alpha: true*/});
			    fbRenderer.setClearColor(0xffffff, 1.0);
			    fbRenderer.setSize(window.innerWidth, window.innerHeight);
			    container.appendChild(fbRenderer.domElement);

			    fbScene = new THREE.Scene();
			    

			    var customShaders = new CustomShaders();
			    var customShaders2 = new CustomShaders();

			    // fbShaders = [ 
			    //     customShaders.flowShader, 
			    //     customShaders.blurShader, 
			    //     customShaders.diffShader2, 
			    //     customShaders.warp2, 
			    //     customShaders.sharpenShader,
			    //     customShaders.bumpShader
			    // ];

			    fbShaders = [ 
			        customShaders.reposShader, 
			        customShaders.blurShader, 
			        customShaders.diffShader, 
			        customShaders2.colorShader, 
			        customShaders2.blurShader,
			        customShaders.bumpShader
			        // customShaders.flowShader, 
			        // customShaders.blurShader, 
			        // customShaders.diffShader, 
			        // customShaders2.flowShader, 
			        // customShaders2.blurShader,
			        // customShaders.bumpShader
			    ];

			    fbMaterial = new FeedbackMaterial(fbRenderer, fbScene, fbCamera, fbTexture, fbShaders);
			        
			    fbMaterial.init();
			    // fbScene.add(new THREE.Mesh(new THREE.PlaneBufferGeometry(window.innerWidth,window.innerHeight),new THREE.MeshBasicMaterial({map:fbTexture})));

			    document.addEventListener( 'keydown', function(){screenshot(fbRenderer)}, false );
			    // document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			    // document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			    // window.addEventListener( 'resize', onWindowResize, false );

			}
			var hide = false;
		function onDocumentMouseMove( event ) {

				mouse.x = ( event.clientX - window.innerWidth / 2 ) * 8;
				mouse.y = ( event.clientY - window.innerHeight / 2 ) * 8;

			    unMappedMouseX = (event.clientX );
			    unMappedMouseY = (event.clientY );
			    if(time > 0.5){
			    	hide = true;			    	
			    }
			    // mouseX = map(unMappedMouseX, window.innerWidth, -1.0/range,1.0/range);
			    mouseX = map(unMappedMouseX, window.innerWidth, -1.0,1.0);
			    // mouseY = map(unMappedMouseY, window.innerHeight, -1.0/range,1.0/range);
			    mouseY = map(unMappedMouseY, window.innerHeight, -1.0,1.0);
			    
			    
			    for(var i = 0; i < fbMaterial.fbos.length; i++){
			      // fbMaterial.fbos[i].material.uniforms.mouse.value = new THREE.Vector2(mouseX, mouseY);
			    }
    

			}
			function fbDraw(){
 
			    for(var i = 0; i < fbMaterial.fbos.length; i++){
			      fbMaterial.fbos[i].material.uniforms.time.value = time;
			      // fbMaterial.fbos[i].material.uniforms.mouse.value = new THREE.Vector2(Math.cos(time*Math.sin(time*0.05))*mouseX, Math.sin(time*Math.cos(time*0.05))*mouseY);
			      // fbMaterial.fbos[i].material.uniforms.mouse.value = new THREE.Vector2(Math.cos(time), Math.sin(time));

			      // if(!hide){
  				      // fbMaterial.fbos[i].material.uniforms.mouse.value = new THREE.Vector2(0.0,0.0);
			      // } else {
  				      fbMaterial.fbos[i].material.uniforms.mouse.value = new THREE.Vector2(mouseX, mouseY);
			      // }
			      // fbMaterial.fbos[i].material.uniforms.mouse.value = new THREE.Vector2(0.0,0.0);
			      fbMaterial.material.uniforms.mouse.value = new THREE.Vector2(window.innerWidth/2, window.innerHeight/2);
			    }
			    fbTexture.needsUpdate = true;
			        
			    fbMaterial.update();
			    if(hide){
				    // fbMaterial.expand(1.002);
			    }
			    fbRenderer.render(fbScene, fbCamera);
			    fbMaterial.getNewFrame();
			    fbMaterial.swapBuffers();
			    fbRenderer.clear(0x000000);

			    capturer.capture( fbRenderer.domElement );

			    
			}

			function hslaColor(h,s,l,a)
			  {
			    return 'hsla(' + h + ',' + s + '%,' + l + '%,' + a + ')';
			  }

		</script>
		<!-- <div><canvas width="1440" height="742"></canvas></div> -->
	

</body></html>